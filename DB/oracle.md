그림으로 공부하는 오라크 구조 책 정리


5.오라클의 기동과 정지(여기 부분은 인스턴스 쪽만)
인스턴스는 백그라운드 프로세스 + 공유메모리 이때 공유 메모리는 공유풀(SQL 실행계획) ,버퍼캐시(조회된 데이터) 를 말합니다.
인스턴스는 한번에 하나씩 데이터베이스를 열어 사용가능
SID = DB하나의 인스턴스
SERVICE NAME = 여러개의 시스템을 모아 하나의 서버 혹은 시스템을 구성한것

사용자 <->서버프로세스 <->인스턴스
RAC(Real Application Clusters)를 사용하는 경우에는 인스턴스와 데이터베이스가 일대일로 대응되지 않는다.
하나의 데이터베이스가 두개의 인스터 로 대응 가능 하고 한개의 인스턴스가 정지하더라도 데이터베이스가 멈추진 않는다. 

6.커넥션과 서버 프로세스의 생성
커넥션을 최적화하는 것만으로도 데이터베이스의 성능을 더욱 끌어올릴수 있다.
오라클에서 소켓의 동작
1.특정 포트 번호로 연락이 오는것을 기다리고 있습니다.
2.커넥션 하고 싶어 상대 장비의 주소와 포트번호를 향해 송신합니다.
3.그후 몇번 송수신을 하고 난후 커넥셕이 확립됩니다.(몇번 송수신은 3way 핸드쉐이크를 말하는듯 하다)

오라클에서는 수신을 기다리는 프로세스를 리스너라고 한다.(서버프로세스가 아니다)
리스너는 한개로 여러 개의 데이터베이스를 안내할 수 있습니다. 물론, 일반적으로는 한개의 리스너로 한개의 데이터베이스를 담당하게 됩니다.
업무 애플리 케이션 안에서 커넥션 명령이 실행되는 순간 커넥션을 수행한다.
ex)java
DataSource ods = new DataSource();
ods.seturl(jdbc:oracle:this:@//xxxxx:1521/ora11g);
Connection conn = ods.getConnection();
This 드라이버의 경우 tnsnames.ora 를 사용하지 않고 커넥션을 위한 정보를 직접 적는다.

소켓을 생성하면 리스너가 그대로 sql 처리를 해도 될것처럼 보이지만, 한번 sql 처리를 시작하면
sql 처리를하느라 다른 처리를 할수 없으므로 즉시 전담 영업 담당자인 서버 프로세스를 생성해서 처리를 인계합니다
서버프러세스가 공유 메모리를 사용할수도 있어야하고 서버프로세스용 메모리도 확보해야 하고 데이터베이스 내부의 처리도 여러가지 남아있다.
따라서 서버 프로세스를 한번 생성 하는 데에는 가벼운  sql 문이 사용하는 시간보다 몇배에서 몇십패 많은 cpu 시간을 사용한다.
그래서 여러 서버 프로세스가 여러 클라이언트의 sql 을 처리할 수 있도록 하면 효율이 높아진다고 생각할수 있습니다. 즉 서버 프로세스
몇개를 풀로 만들어두고 여러 애플리케이션이 자신이 쓰고 싶을때만 풀에서 하나를 꺼내 사용한다는 구조를 생각할수 있다.


![image](https://user-images.githubusercontent.com/40969203/112471924-d9ee5300-8daf-11eb-8c99-8a3e1ca3ee55.png)

            
            
