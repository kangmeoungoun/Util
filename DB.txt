--트랜잭션--

1. 트랜잭션의 성질
 원자성(Atomicity) :트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실해되지 않은 상태로 남아 있어야 한다. (all or nothing)
 일관성(Consistency):트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안된다.
 격리성(Isolation) : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다.
 지속성(Durability): 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저정된다.

2.SQL Server에서의 트랜잭션은 기본적으로 3가지 방식으로 이루어진다.
AUTO COMMIT :SQL Server의 기본 방식이며, DML,DDL 을 수행할 때마다 DBMS 가 트랜잭션을 컨트롤 하는 방식이다.
              명령어가 성공적으로 수행되면 자동으로 COMMIT을 수행하고 오류가 발생하면 자동으로 ROLLBACK을 수행한다.

암시적 트랜잭션 : Oracle 과 강은 방식으로 처리된다. 즉, 트랜잭션의 시작은 DBMS 가 처리하고 트랜잭션의 끝은 사용자가 명시적으로 COMMIT 또는 ROLLBACK으로 처리한다.

명시적 트랜잭션  : 트랜잭션의 시작과 끝을 모두 사용자가 명시적으로 지정하는 방식이다. BEGIN TRANSACTION (BEGIN TRAN 구문도 가능) 으로 트랜잭션을 시작하고 
                  COMMIT TRANSACTION(TRANSACTION은 생략 가능) 또는 ROLLBACK TRANSACTION(TRANSACTION은 생략 가능)으로 트랜잭션을 종료한다.

3.다수의 트랜잭션이 경쟁시 발생할 수 있는 문제
Dirty Read :  트랜잭션 A가 어떤 값을 1에서 2로 변경하고 아직 커밋하지 않은 상황에서 트랜잭션B가 같은 값을 읽는 경우 트랜잭션 B는 2가 조회 된다.
               트랜잭션 B가 2를 조회 한 후 혹시 A가 롤백된면 결국 트랜잭션B는 잘못된 값을 읽게 된 것이다. 즉, 아직 트랜잭션이 완료되지 않은 상황에서 데이터에 접근을 허용할 경우 발생할 수 있               는 데이터 불일치이다.

Non-Repeatable Read :트랜잭션 A가 어떤 값 1을 읽었다. 이후 A는 같은 쿼리를 또 실행할 예정인데, 그 사이에 트랜잭션 B가 값 1을 2로 바꾸고 커밋해버리면 A가 같은 쿼리 두번을 날리는 사이 두 쿼                     리의 결과가 다르게 되어 버린다. 즉, 한 트랜잭션에서 같은 쿼리를 두번 실행했을 때 발생할 수 있는 데이터 불일치이다.

Phantom Read : 트랜잭션 A가 어떤 조건을 사용하여 특정 범위의 값들[0,1,2,3,4]을 읽었다. 이후 A는 같은 쿼리를 실행할 예정인데, 그 사이에 트랜잭션 B가 같은 테이블에 값[5,6,7]을 추가해버리면 A가 같은 쿼리 두번을 날리는 사이 두 쿼리의 결과가 다르게 되어 버린다.즉, 한 트랜잭션에서 일정 범위의 레코드를 두번 이상 읽을 때 발생하는 데이터 불일치이다.

4.트랜잭션 속성
READ_UNCOMMITTED (level 0) :  커밋되지 않는(트랜잭션 처리중인) 데이터에 대한 읽기를 허용 즉 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 B라는 아직 완료되지 않은                                  (Uncommitted 혹은 Dirty) 데이터 B를 읽을 수 있다.

READ_COMMITTED (level 1) : 트랜잭션이 커밋 된 확정 데이터만 읽기 허용 어떠한 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.

SERIALIZABLE (level 3) : 데이터의 일관성 및 동시성을 위해 MVCC(Multi Version Concurrency Control)을 사용하지 않음
                        (MVCC는 다중 사용자 데이터베이스 성능을 위한 기술로 데이터 조회 시 LOCK을 사용하지 않고 데이터의 버전을 관리해 데이터의 일관성 및 동시성을 높이는 기술)
                        트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 shared lock이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다.
