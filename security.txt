전자 서명 원리 https://d2.naver.com/helloworld/744920

내가 이해한부분 추출

- 해시값 을 지문이라고 표현
  해시함수는 0과 1로 조합된 길게 이루어진 바이너리로부터 그바이너리로 대표하며 축약할 수 있는 해시값 
  즉 바이너리의 지문을 추출하는 함수.
  
  -대칭키 암호화
   A->C , B->D,X->Y 와 같이 바뀐다면 YES 는 AUG 로 암호화 된다. 이떄 암호화의 열쇠가 있는데 이열쇠는 숫자 2
   암호화 열쇠 2를 사용하여 암호화할수도 있고 복호화 할수도 있다.
   대칭키 방식의 근본적인 문제는 열쇠자체가 유출될 위험이 존재.
   이런 근본적인 문제를 해결하기위해 나온 암호화 방법이 비대칭키 암호화 ,보통 공개키 암호화 방식이라고 한다.
   
   -공개키 암호화
   가장 큰 특징은 열쇠가 두개라는 것 하나는 암호화하는 열쇠 다른하나는 복호화 하는 열쇠로 사용된다.
   EX) 영희가 비대칭 한쌍(암호화키 KeyyE,복호화키 KeyD)를 생성 후 철수에게 암호화키 전달.
       철수는 암호화키 KeyE 를 이용하여 암호화를 수행하고 암호화된 메시지를 영희에게 전송
       영희는 복호화키 KeyD 를 이용하여 복호화를 수행 후 메시지 확인.
       
   암호화 키는 공개되고 복호화는 개인키라고 생각할수 있는데 꼭 그렇지만은 않다 복호화키를 공개 하면서 암호화 키는 개인키가 될수도 있다.
   전자 서명에서는 복호화 키고 공개
   
   
   -무결성 확인
   무결성이란 A가 B 에게 메시지를 전송할 경우 메시지가 중간에 변조되지 않는 것을 의미
   무결성을 확인한다는것은 바이너리가 변조되지 않았음을 확인하는것 이때 사용되는 기술이 바로 해시함수.
   Internet Explorer 11 설치파일에 대한 해시값인 지문정보를 공개 
   사용자들은 설치파일을 다운로드 한 뒤 해시함수를 이용하여 지문 정보를 알아내고 그것이 마이크로소프트에서 공개된 지문정보와 일치하는 지
   확인하여 다운로드한 설치 파일이 올바른 설치파일인지 확인.
   
   
   -진보된 무결성 확인
   해시 함수만을 사용하는데 취약점 보완하기 위하여 비대칭키 암호화 사용
   네이버는 비대칭키 암호화에 사용할 키 한쌍(암호화키[개인키] KeyE,복호화키[공개키]KeyD)를 생성
   해시함수를 사용하여 Napp 바이너리 B1 의 지문 H1 을 얻어낸다.
   그리고 암호화 키 KeyD 를 이용하여 H1 을 암호화 한다. 지문을 암호화 하여 나온 값을 보통 서명 이라고 한다. 서명을 S 라고 한다.
   원본 바이너리 B1 에 서명 S 와 복호화키 KeyD 를 추가하여 새로운 배포 버전용 바이너리인 C1 을 생성 
   원본바이너리에서 서명과 공개키를 추가하여 새로운 바이너리를 만드는 과정을 코드사인 이라고 부른다. 
   C1 = {B1,S,KeyD}
   
   코드사인 과정
   
   Hash(B1) -> H1         //해시함수에 바이너리를 넣어 지문을 얻고
   Encrypt(H1,KeyE) -> S  //지문을 암호화키 로 암호화하여 서명 을 얻는다.
   C1 = {B1,S,KeyD}       // 바이너리 서명 복호화키 를 묶어서 코드사인 바이너리 생성
   
   C1 = B1,S,KeyD         // 다운받은 C1을 바이너리 서명 복호하키로 분리
   Decrypt(S,KeyD) -> H1  // 서명 을 공개키로 복호화하여 지문을 얻는다.
   Hash(B1)        -> H1  // 바이너리를 해시함수에 입력하여 지문을 얻는다.
   H1 == H1 ,Execute      // 두 지문이 일치하는것을 확인.
   
   해커가 변조한 코드사인 과정 C1 을만드는 코드사인 과정은 동일
   
   C1 = B1,S,KeyD   // 해커는 C1을 획득하여 B2,S,KeyD로 분리
   B1->B2           // B1을 B2로 변조
   C2 = {B2,S,KeyD}   // 변조한바이너리,서명,공개키를 묶으서 코드사인 바이너리 생성
   C1 -> C2         // 해커는 네이버 배포 서버의 C1 을 C2로 바꿔치기
   
   C2 = B2,S,KeyD        // 다운받은 C2을 바이너리 서명 복호하키로 분리
   Decrypt(S,KeyD) -> H1 // 서명을 공캐키로 복호화 하여 지문1 을 얻는다
   Hash(B2) -> H2        // 바이너리를 해시함수에 입력하여 지문2 를 얻는다.
   H1 != H2, Ignore      // 두 지문이 일치하지 않음을 확인.
   
   미흡한 부분 찾기
   
   C1 = B1,S,KeyD          // 해커는 C1을 획득하여 B2,S,KeyD로 분리
   B1->B2                  // B1을 B2로 변조
   Hash(B2) -> H2          // B2를 해시함수에 입력 하여 지문 H2 를 얻는다.
   Encrypt(H2,FKeyE) -> S2 // H2 를 개인키 FkeyD 로 암호화하여 S2 를 얻는다.
   C2 = {B2,S2,FkeyD}      // B2,S2,공개키 FkeyD 를 묶어서 코드사인 바이너리C2 생성
   C1 -> C2                // 해커는 네이버 배포 서버의 C1 을 C2로 바꿔치기
   
   C2 = B2,S2,FKeyD         // 다운받은 C2을 B2,S2,FkeyD 로 분리
   Decrypt(S2,FkeyD)  -> H2 // S2를 FkeyD로 복호화 하여 H2를 얻는다.
   Hash(B2)           -> H2 // B2를 해시함수에 입력하여 H2를 얻는다.
   H2 == H2  Execute 망함   // 두지문이 일치하는것을 확인.
   
   -공인인증서
   위에 같은 문제 즉 해커가 직접 자신의 개인키를 이용하여 서명을 하고 공개키를 공개해서 코드사인을 한면 무결성 검증을 통과하는 문제를
   해결하기위해 등장한 것이 공인인증서.
   간략하게 복호화키인 공개키를 파일 형태로 만들어 놓은것.
   인증서는 다양한 정보가 기록되지만 그중에서도 중요한 몇가지 주체(네이버),주체(네이버의 공개키, 발급자, 그리고 인증서에 들어 있는 정보에 대한 발급자의 서명
   
   네이버는 일반적으로 알려진 신뢰할수 있는 공인인증 기관에 복호화에 사용할 공개키와 네이버라는 사명을 등록 
   공인인증 기관은 등록된 공개키가 네이버의 것이라는 것을 인증해주는 역할 이때 공인인증 기관은 네이버에게 인증서를 발급한다.
   이 인증서에 는 네이버라는 주체와 네이버가 등록한 공개키,공인인증기과자신을 나타내는 발급자 정보, 발급자 서명 이 기록된다.
   발급자 서명은 인증서에 기록된 여러 정보를 하나로 모은후 해시함수에 입력하여 지문을 얻어내고 발급자의 암호화키[개인키] 로 해당 지문에 대한 암호화 한 결과를 말한다.
   인증서가 변조되지 않았고, 그 인증서에 주체가 네이버 로 기록되어 있다면 그 인증서는 네이버가 발급받은 것이라고 믿을수 있다.
   
   
   -인증서를 이용하여 진보된 무결성 확인
   
   네이버는 비대칭키 암호화에 사요ㅕㅇ할 키 한쌍(암호화키[개인키] KeyE, 복호화키[공개키]KeYD) 를 생성한다. 그리고 신뢰할수 있는 발급자에게 
   복호화키인 공개키 KeyD를 등록하면서 인증서를 발급받는다.
   인증서에는 네이버라는 주체와 함께 공캐기KeyD가 기록되어있다.
   이제는 새롭게 코드사인된 바이너리 C1 은 바이너리,서명,인증서 를 포합한다.
   
   C1 = {B1,S,인증서}
   사용자는 앞에서 진행했던 과정과 동일 다른점 인증서에 기록된 공개키를 동해 서 서명 을 복호화
   이작업에 이어 두 단계에 걸쳐 추가적인 검증을 진행한다.
   
   첫번째로 인증서에 적힌 주체가 네이버임을 확인해서 인증서가 네이버의 것임을 확인한다.
   두번째로 인증서에 기록된 발급자의 서명을 발급자의 공개키로 복호화하여 지문을 얻고 인증서에 기록된 정보들을 해시함수에 입력하여 지문을 얻어내서
   두지문의 일치여부를 확인한다. 두 지문이 일치한다면 인증서 자체가 변조된 적이 없는 것이다.
   
   발급자의 공캐키 발급자의 서명도 인증서에 포함된다.
   그럼 발급자의 인증서는 어떻게 믿을수 있을까?
   발급자의 인증서로 네이버 인증서를 검증하듯이 발급자의 인증서는 한 단계 높은 상위 발급자의 인증서로 검증한다. 결국 이런 과정이 반복되면
   최상위의 발급자인 공인 인증 기관을 만나게 된다. 최상위 공인 인증 기관을 Root인증 기관 이라고 한다 Root 인증기관의 인증서에는 주체와 발급자가 동일하다.
   
   인증서는 몇단계에 걸친 인증구조로 구성된다. 이런 구조를 인증서 체인이라고 부른다. 인발적으로 인증서 체인은 3단계 정도로 구성된다.
   Root 인증서는 윈도우 시스템에 내장되어 있기 때문에 쉽게 구할수 있다. 
   
   
   
  ------
  내가 이해하 부분만 정리한것.어쩌다 이걸 정리하게 되었냐면 프로젝트 SSO 연동하다 인증서에 대한 개념이 없어서 하게 되었다. 
